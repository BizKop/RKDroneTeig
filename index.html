<html>

<head>
    <title>RK Droneteig</title>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
    <style>
        /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
        #map {
            height: 100%;
        }

        /* Optional: Makes the sample page fill the window. */
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        a.button4 {
            display: inline-block;
            padding: 0.3em 1.2em;
            margin: 0 0.1em 0.1em 0;
            border: 0.16em solid rgba(255, 255, 255, 0);
            border-radius: 2em;
            box-sizing: border-box;
            text-decoration: none;
            font-family: 'Roboto', sans-serif;
            font-weight: 300;
            color: #FFFFFF;
            text-shadow: 0 0.04em 0.04em rgba(0, 0, 0, 0.35);
            text-align: center;
            transition: all 0.2s;
        }

        input,label,select {
            display: inline-block;
            padding: 0.3em 1.2em;
            margin: 0 0.1em 0.1em 0;
            border: 0.16em solid rgba(255, 255, 255, 0);
            border-radius: 2em;
            box-sizing: border-box;
            text-decoration: none;
            font-family: 'Roboto', sans-serif;
            font-weight: 300;
            color: #100404;
            text-align: left;
            transition: all 0.2s;
        }

        a.button4:hover {
            border-color: rgba(255, 255, 255, 1);
        }

        a.button4:disabled,button4[disabled] {
            background-color: #cccccc;
            color: #666666;
        }

        @media all and (max-width:30em) {
            a.button4 {
                display: block;
                margin: 0.6em auto;
            }
        }
    </style>
    <script src="xmlwriter.js" type="text/javascript"></script>
</head>

<body>
    <!-- Hjemme hos Hans Erik -->
    <!-- latitude:<input type="text" id="latitude" value="59.824540">
    longitude:<input type="text" id="longitude" value="10.419550"> -->

    <!-- Depot Asker -->
    <!-- latitude:<input type="text" id="latitude" value="59.842809">
    longitude:<input type="text" id="longitude" value="10.422982"> -->

    <!-- Kolsåsbakken -->
    <!--latitude:<input type="text" id="latitude" value="59.93609640271338">
    longitude:<input type="text" id="longitude" value="10.522853115520695"> -->

    <!-- Vinnulstad Gård -->
    Latitude:<input type="text" id="latitude" value="59.801988">
    Longitude:<input type="text" id="longitude" value="10.425938">    
    <br>

    <select id="pattern-select">
        <option value="">-- Choose a search pattern --</option>
        <option value="rectangel">Rectangel</option>
        <option value="sector">Sector (SS3)</option>
        <option value="archspiral">Archimedes Spiral</option>
        <option value="squarespiral">Square Spiral</option>
    </select>

    Altitude(m):<input type="text" id="flightAltitude" value="70">
    <br>
    Pattern width(m):<input type="text" id="teigWidth" value="90">
    Pattern height(m):<input type="text" id="teigHeight" value="90">

    <br>
    <a href="javascript:initMap();" class="button4" style="background-color:#4e9af1">Reset TakeOff to Lat-Lon</a>
    <a href="javascript:mapToObject();" class="button4" style="background-color:#f14e4e">Generate FlightPath</a>
    <a href="javascript:toKML();" class="button4" id="downloadButton" style="background-color:#f14e4e">Download KML</a>

    <script async
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBJsSfRxk6h_MBkD7XF7F4IMHh4G_q8Fj4&libraries=drawing,geometry&callback=initMap">
        </script>
    <div id="map"></div>

    <textarea id="kmlString" style="width:100%; height:300px"></textarea>

    <script>
        var map;
        var mapOverlays = [];
        var takeOffMarker;
        var drawingManager;
        var flightPath;
        var flightPathElevations;
        var setflightAltitude;
		var teigWidth = 90;
		var teigHeight = 90;
        var takeOffLat;
        var takeOffLng;
        var takeOffElevation;
        var selectedPattern = "";
        var flightMissionName;
        var kml;

        function initMap() {

            const downloadButton = document.querySelector('downloadButton');
            const disableButton = () => {
                downloadButton.disabled = true;
                downloadButton.style = diabled;
            };

            takeOffLat = Number(document.getElementById("latitude").value);
            takeOffLng = Number(document.getElementById("longitude").value);
            setflightAltitude = parseInt(document.getElementById("flightAltitude").value);
			teigWidth = parseInt(document.getElementById("teigWidth").value);
			teigHeight = parseInt(document.getElementById("teigHeight").value);
            console.log("FlightAltitude: " + setflightAltitude);

            takeOffLoc = { lat: takeOffLat, lng: takeOffLng };
            map = new google.maps.Map(document.getElementById('map'), {
                center: takeOffLoc,
                zoom: 18,
                // mapTypeId: "satellite",
                mapTypeId: "hybrid",
            });

            const Helipad_image = "https://cdn-icons-png.flaticon.com/32/1595/1595205.png";

            // The marker, positioned at TakeOff center location
            takeOffMarker = new google.maps.Marker({
                position: takeOffLoc,
                map: map,
                icon: Helipad_image,
                draggable: true,
            });

            // Add all listeners needed to enable moving and drawing new coords in the flightPath
            google.maps.event.addListener(takeOffMarker, 'dragend', changeTakeOffLocation);
            
            function LogMessage(sometext)
            {
                console.log(sometext);
            }

            getLocationElevation(takeOffLoc).then(
                function(value) {takeOffElevation = value;},
                function(error) {LogMessage(error);}
            );

            drawingManager = new google.maps.drawing.DrawingManager();
            drawingManager.setMap(map);

            const sel_pattern = document.getElementById('pattern-select');
            sel_pattern.addEventListener('change', function handleChange(event) {
                selectedPattern = event.target.value;
				
				takeOffLat = Number(document.getElementById("latitude").value);
				takeOffLng = Number(document.getElementById("longitude").value);
				setflightAltitude = parseInt(document.getElementById("flightAltitude").value);
				teigWidth = parseInt(document.getElementById("teigWidth").value);
				teigHeight = parseInt(document.getElementById("teigHeight").value);
				
				
                console.log("Changing pattern to: ", event.target.value); // 👉️ get selected VALUE
                switch (selectedPattern) {
                    case "rectangel":
						CreateFlightPathRectangle(takeOffLat, takeOffLng, teigWidth, teigHeight);
                        //CreateFlightPathSquare(takeOffLat, takeOffLng, teigWidth, teigHeight);
                        break;
                    case "archspiral":
                        CreateFlightPathArchimedesSpiral(takeOffLat, takeOffLng, teigWidth, teigHeight);
                        break;
                    case "squarespiral":
                        CreateFlightPathSquareSpiral(takeOffLat, takeOffLng,teigWidth, teigHeight);
                        break;
                    case "sector":
                        CreateFlightPathSector(takeOffLat, takeOffLng, teigWidth, 120);
//                        CreateFlightPathSector(takeOffLat, takeOffLng, 60, 120);
                        break;
                    default:
                        break;
                }

            });
        }

        function changeTakeOffLocation() {
            takeOffLng = takeOffMarker.getPosition().lng();
            takeOffLat = takeOffMarker.getPosition().lat();

            takeOffLoc = { lat: takeOffLat, lng: takeOffLng };

            console.log("Changed location of TakeOff to Lng: " + takeOffLng + " Lat: " + takeOffLat);

            document.getElementById("latitude").value = takeOffLat;
            document.getElementById("longitude").value = takeOffLng;

        }

        async function getLocationElevation(location) {
            // Initiate the location request
            console.log("Finding Height Above Ground Level");
            const elevator = new google.maps.ElevationService();
            await elevator.getElevationForLocations({
                locations: [location],
            })
                .then(({ results }) => {
                    // Retrieve the first result
                    if (results[0]) {
                        takeOffElevation = results[0].elevation;
                        console.log("The TakeOff elevation is " + takeOffElevation + " meters.");
                    } else {
                        console.log("No TakeOff elevation results found");
                    }
                })
                .catch((e) =>
                    console.log("Elevation service failed due to: " + e)
                );
                return takeOffElevation;
            }

        function getFlightPathElevations(flightPathLocations) {
            // Initiate the location request
            console.log("Finding Height Above Ground Level for all points in flightPath");
            const elevator = new google.maps.ElevationService();
            elevator.getElevationForLocations({
                locations: flightPathLocations, 
            })
                .then(({ results }) => {
                    flightPathElevations = results;
                    console.log("Elevation service have calculated height for all points")
                    flightPathElevations.forEach(element => {
                        console.log(element);
                    }); 
                })
                .catch((e) =>
                    console.log("Elevation service failed due to: " + e)
                );
        }        

        <!-- function CreateFlightPathSquare(teigCenterLat, teigCenterLng, teigWidth, teigHeight) { -->

            <!-- // Find the corners of the rectangle based on width / height -->
            <!-- teigLowerLeftLat = CreateOffsetLatitude(teigCenterLat, -(teigWidth / 2)); -->
            <!-- teigLowerLeftLng = CreateOffsetLongtitude(teigCenterLng, -(teigHeight / 2)); -->
            <!-- teigLowerRightLat = CreateOffsetLatitude(teigCenterLat, (teigWidth / 2)); -->
            <!-- teigLowerRightLng = teigLowerLeftLng; -->
            <!-- teigUpperLeftLat = teigLowerLeftLat; -->
            <!-- teigUpperLeftLng = CreateOffsetLongtitude(teigCenterLng, (teigHeight / 2)); -->
            <!-- teigUpperRightLat = CreateOffsetLatitude(teigCenterLat, (teigWidth / 2)); -->
            <!-- teigUpperRightLng = CreateOffsetLongtitude(teigCenterLng, (teigHeight / 2)); -->

            <!-- // Create array with all coordinates in rectangle -->
            <!-- const points = [ -->
                <!-- { lat: teigLowerLeftLat, lng: teigLowerLeftLng }, -->
                <!-- { lat: teigUpperLeftLat, lng: teigUpperLeftLng }, -->
                <!-- { lat: teigUpperRightLat, lng: teigUpperRightLng }, -->
                <!-- { lat: teigLowerRightLat, lng: teigLowerRightLng }, -->
                <!-- { lat: teigLowerLeftLat, lng: teigLowerLeftLng }, -->
            <!-- ]; -->

            <!-- setPolylineInMap(points) -->
        <!-- } -->
		
		
        function CreateFlightPathRectangle(teigCenterLat, teigCenterLng, patternWidth, patternHeight) {

			// Find the lower left center of the search pattern (100 m from takeoff)
			lastPointLat = CreateOffsetLatitude(teigCenterLat, 100);
			lastPointLng = CreateOffsetLongtitude(teigCenterLng, 0);

			const points = [];
			distance = patternWidth;
			
			//Add the lower left corner
            points.push({ lat: lastPointLat, lng: lastPointLng });
			
			// Add 90 degrees clockwise and move teightWidth or teigHeight
			let intialAngle = 0, angle=0, moveAngle = 90;
            let i = 0;
			
			while (i <= 3)
			{
				angle = intialAngle + i * moveAngle;
				
				
				//check if leg is 2 or 4 (height)
				if(i == 0 || i == 2) {
					distance = patternHeight;
				}
				else
				{
					distance = patternWidth;
				}
				
				lastPointLat = movePointLat(lastPointLat,lastPointLng,distance,angle);
				lastPointLng = movePointLon(lastPointLat,lastPointLng,distance,angle);
				
				points.push({ lat: lastPointLat, lng: lastPointLng });
				i++;
			}
		
            setPolylineInMap(points)
        }	
		
		
        function CreateFlightPathSector(teigCenterLat, teigCenterLng, patternWidth, teigOffset) {

			// Find the center of the search pattern
			teigCenterLat = CreateOffsetLatitude(teigCenterLat, teigOffset);
			teigCenterLng = CreateOffsetLongtitude(teigCenterLng, teigOffset);

			const points = [];
			distance = patternWidth;
			
			//Add the center
            points.push({ lat: teigCenterLat, lng: teigCenterLng });
			
			// Fly teigWidth (60m) in northbound direction and add to pattern
			lastPointLat = movePointLat(teigCenterLat,teigCenterLng,patternWidth,0);
			lastPointLng = movePointLon(teigCenterLat,teigCenterLng,patternWidth,0);
            points.push({ lat: lastPointLat, lng: lastPointLng });
			
			// Add 120 degrees clockwise and move 60 m
			let intialAngle = 0, angle=0, moveAngle = 120;
            let i = 1, x = 0, y = 0;
			
			while (i <= 6)
			{
				angle = intialAngle + i * moveAngle;
				
				
				//check if leg is 2 or 4 (double length
				if(i == 2 || i == 4) {
					distance = patternWidth * 2;
				}
				else
				{
					distance = patternWidth;
				}
				
				lastPointLat = movePointLat(lastPointLat,lastPointLng,distance,angle);
				lastPointLng = movePointLon(lastPointLat,lastPointLng,distance,angle);
				
				points.push({ lat: lastPointLat, lng: lastPointLng });
				i++;
			}
		
            setPolylineInMap(points)
        }	
		function toRadians(degrees)
		{
		  return degrees * (Math.PI/180);
		}	
		
		function toDegrees(radians)
		{
		  return radians * (180/Math.PI);
		}

		<!-- function movePoint(latitude, longitude, distanceInMetres, bearing) { -->
			<!-- brngRad = toRadians(bearing); -->
			<!-- latRad = toRadians(latitude); -->
			<!-- lonRad = toRadians(longitude); -->
			<!-- earthRadiusInMetres = 6371000; -->
			<!-- distFrac = distanceInMetres / earthRadiusInMetres; -->

			<!-- latitudeResult = Math.asin(Math.sin(latRad) * Math.cos(distFrac) + Math.cos(latRad) * Math.sin(distFrac) * Math.cos(brngRad)); -->
			<!-- a = Math.atan2(Math.sin(brngRad) * Math.sin(distFrac) * Math.cos(latRad), Math.cos(distFrac) - Math.sin(latRad) * Math.sin(latitudeResult)); -->
			<!-- longitudeResult = (lonRad + a + 3 * Math.PI) % (2 * Math.PI) - Math.PI; -->

			<!-- console.log("lat: " + toDegrees(latitudeResult) + ", lon: " + toDegrees(longitudeResult)); -->
			<!-- return { lat: toDegrees(latitudeResult), lng: toDegrees(longitudeResult) }; -->
		<!-- } -->

		function movePointLat(latitude, longitude, distanceInMetres, bearing) {
			brngRad = toRadians(bearing);
			latRad = toRadians(latitude);
			lonRad = toRadians(longitude);
			earthRadiusInMetres = 6371000;
			distFrac = distanceInMetres / earthRadiusInMetres;

			latitudeResult = Math.asin(Math.sin(latRad) * Math.cos(distFrac) + Math.cos(latRad) * Math.sin(distFrac) * Math.cos(brngRad));
			return toDegrees(latitudeResult);
		}
		
		function movePointLon(latitude, longitude, distanceInMetres, bearing) {
			brngRad = toRadians(bearing);
			latRad = toRadians(latitude);
			lonRad = toRadians(longitude);
			earthRadiusInMetres = 6371000;
			distFrac = distanceInMetres / earthRadiusInMetres;

			latitudeResult = Math.asin(Math.sin(latRad) * Math.cos(distFrac) + Math.cos(latRad) * Math.sin(distFrac) * Math.cos(brngRad));
			a = Math.atan2(Math.sin(brngRad) * Math.sin(distFrac) * Math.cos(latRad), Math.cos(distFrac) - Math.sin(latRad) * Math.sin(latitudeResult));
			longitudeResult = (lonRad + a + 3 * Math.PI) % (2 * Math.PI) - Math.PI;

			return toDegrees(longitudeResult);
		}		

        function CreateFlightPathArchimedesSpiral(teigCenterLat, teigCenterLng, teigWidth, teigHeight) {

            let a = 10, b = 5, angle = 0;
            let x = 0, y = 0;

            const points = [];

            const acceleration = 0.7, circleNum = 5;
            lastPointLat = teigCenterLat;
            lastPointLng = teigCenterLng;

            i = 0

            //Note that the angle here increases by 2 * math Compare Pi as the benchmark and control how many circles to draw
            while (angle <= circleNum * 2 * Math.PI) {

                x = (a + b * angle) * Math.sin(angle);
                y = (a + b * angle) * Math.cos(angle);
                lastPointLat = CreateOffsetLatitude(lastPointLat, x)
                lastPointLng = CreateOffsetLongtitude(lastPointLng, y)
                //            console.log(lastPointLat.toString(),', ',lastPointLng.toString());

                points.push({ lat: lastPointLat, lng: lastPointLng });
                angle = angle + acceleration;
                i++;
            }

            setPolylineInMap(points);
        }

        function CreateFlightPathSquareSpiral(teigCenterLat, teigCenterLng, teigWidth, teigHeight) {

            const points = [];

            let x = 0, y = 0, dx = 0, dy = -1;
            var t = Math.max(teigWidth, teigHeight);
            var maxI = teigWidth * t;
            lastPointLat = teigCenterLat;
            lastPointLng = teigCenterLng;


            for (i = 0; i < maxI; i++) {
                if ((-teigWidth / 2 <= x) && (x <= teigWidth / 2) && (-teigHeight / 2 <= y) && (y <= teigHeight / 2)) {
                    lastPointLat = CreateOffsetLatitude(lastPointLat, x)
                    lastPointLng = CreateOffsetLongtitude(lastPointLng, y)
                                console.log(lastPointLat.toString(),', ',lastPointLng.toString());

                    points.push({ lat: lastPointLat, lng: lastPointLng });
                }

                if ((x == y) || ((x < 0) && (x == -y)) || ((x > 0) && (x == 1 - y))) {
                    t = dx; dx = -dy; dy = t;
                }
                x += dx; y += dy;
            }

            setPolylineInMap(points);
        }



        function setPolylineInMap(points) {

            // Remove earlier flightpaths
            cleanMapForFlightRoutes();

            // Set the icon to see the direction of the flightpath
            iconSequence = {
                icon:
                {
                    path: google.maps.SymbolPath.FORWARD_OPEN_ARROW
                },
                repeat: '20%'
            }

            // Create the polyline with all coordinates
            flightPath = new google.maps.Polyline({
                path: points,
                geodesic: true,
                strokeColor: "#C4FF00",
                strokeOpacity: 1.0,
                strokeWeight: 4,
                draggable: true,
                editable: true,
                icons: [iconSequence],
            });

            // Add the flightpath to the map
            flightPath.setMap(map);
            flightPath.type = "polyline";

            // Add the flightPath to the list of overlays for KML Export
            mapOverlays.push(flightPath);

//            getFlightPathElevations(points);
//            getFlightPathElevations(flightPath.getPath().Array());


            // Add all listeners needed to enable moving and drawing new coords in the flightPath
            google.maps.event.addListener(flightPath, 'dragend', getPolygonCoords);
            google.maps.event.addListener(flightPath.getPath(), 'insert_at', getPolygonCoords);
            google.maps.event.addListener(flightPath.getPath(), 'remove_at', getPolygonCoords);
            google.maps.event.addListener(flightPath.getPath(), 'set_at', getPolygonCoords);

        }

        //
        function cleanMapForFlightRoutes() {
            for (i = 0; i < mapOverlays.length; i++) {
                mapOverlays[i].setMap(null);
            }
            mapOverlays = [];
        }

        function getPolygonCoords() {
            var geoArray = flightPath.getPath();
            geoArray.forEach(element => {
                console.log(element.toString());
            });
            console.log("Length: ", google.maps.geometry.spherical.computeLength(geoArray), " meters");
        }

        function CreateOffsetLatitude(orgLatitude, offsetMeters) {
            //Earth’s radius, sphere
            R = 6378137;
            Pi = 3.14159;

            //Coordinate offsets in radians
            dLat = offsetMeters / R;

            //OffsetPosition, decimal degrees
            return parseFloat(orgLatitude + dLat * 180 / Math.PI);
        }

        function CreateOffsetLongtitude(orgLongtitude, offsetMeters) {
            //Earth’s radius, sphere
            R = 6378137

            //Coordinate offsets in radians
            dLon = offsetMeters / (R * Math.cos(Math.PI * orgLongtitude / 180))

            //OffsetPosition, decimal degrees
            return parseFloat(orgLongtitude + dLon * 180 / Math.PI);
        }

        function download() {
            // Start file download.
            var filename = flightMissionName + ".kml";

            var element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(kml));
            element.setAttribute('download', filename);

            element.style.display = 'none';
            document.body.appendChild(element);

            element.click();

            document.body.removeChild(element);
        }


        function toKML() {
            var xw = new XMLWriter('UTF-8');
            var flightAltitude = setflightAltitude;
            console.log("FlightAltitude: " + setflightAltitude);
            // Set default altitude to 50m if not set by user
            if (isNaN(flightAltitude)) {
                flightAltitude = 50;
            } else {
                // Override illegal options
                if (flightAltitude < 0 || flightAltitude > 120) {
                    flightAltitude = 50;
                }
            }

            var calculatedFlightAltitude;

            const today = new Date();
            flightMissionName = "FlightMission-" + formatDate(today, 'ddmmyyyy-hhmi');
            var flightMissionLength = " - Length: " + google.maps.geometry.spherical.computeLength(flightPath.getPath()) + " meters";

            xw.formatting = 'indented';//add indentation and newlines
            xw.indentChar = ' ';//indent with spaces
            xw.indentation = 2;//add 2 spaces per level

            xw.writeStartDocument();
            xw.writeStartElement('kml');
            xw.writeAttributeString("xmlns", "http://www.opengis.net/kml/2.2");
            xw.writeStartElement('Document');

            for (var i = 0; i < kmlObject.overlays.length; i++) {
                xw.writeStartElement('Placemark');
                xw.writeStartElement('name');
                xw.writeCDATA(flightMissionName);
                xw.writeEndElement();
                xw.writeStartElement('description');
                xw.writeCDATA("Teig flightpath for " + flightMissionName + flightMissionLength + " - Flying at " + flightAltitude + " meters" + 
                " - Taking of from " + parseInt(takeOffElevation) + " meters above sea level");
                xw.writeEndElement();
                console.log("Overlay " + i + " is a " + kmlObject.overlays[i].type);
                if (kmlObject.overlays[i].type == "marker") {
                    xw.writeStartElement('Point');
                    xw.writeElementString('extrude', '1');
                    xw.writeElementString('altitudeMode', 'relativeToGround');
                    xw.writeElementString('coordinates', kmlObject.overlays[i].position.lng.toString() + "," + kmlObject.overlays[i].position.lat.toString() + "," + flightAltitude);
                    xw.writeEndElement();

                } else if (kmlObject.overlays[i].type == "polygon" || kmlObject.overlays[i].type == "rectangle" || kmlObject.overlays[i].type == "circle") {
                    xw.writeStartElement('Polygon');
                    xw.writeElementString('extrude', '1');
                    xw.writeElementString('altitudeMode', 'relativeToGround');

                    if (kmlObject.overlays[i].type == "rectangle") {
                        //its a polygon
                        xw.writeStartElement('outerBoundaryIs');
                        xw.writeStartElement('LinearRing');
                        xw.writeStartElement("coordinates");
                        xw.writeString(kmlObject.overlays[i].bounds.sw.lng + "," + kmlObject.overlays[i].bounds.sw.lat + "," + flightAltitude);
                        xw.writeString(kmlObject.overlays[i].bounds.ne.lng + "," + kmlObject.overlays[i].bounds.sw.lat + "," + flightAltitude);
                        xw.writeString(kmlObject.overlays[i].bounds.ne.lng + "," + kmlObject.overlays[i].bounds.ne.lat + "," + flightAltitude);
                        xw.writeString(kmlObject.overlays[i].bounds.sw.lng + "," + kmlObject.overlays[i].bounds.ne.lat + "," + flightAltitude);
                        xw.writeEndElement();
                        xw.writeEndElement();
                        xw.writeEndElement();
                    } else if (kmlObject.overlays[i].type == "circle") {
                        //its a polygon, approximate a circle by a circular 64 sided polygon.
                        xw.writeStartElement('outerBoundaryIs');
                        xw.writeStartElement('LinearRing');
                        xw.writeStartElement("coordinates");
                        var d2r = Math.PI / 180;   // degrees to radians
                        var r2d = 180 / Math.PI;   // radians to degrees
                        var earthsradius = 6378137; // 6378137 is the radius of the earth in meters
                        var dir = 1; // clockwise

                        var points = 64;

                        // find the raidus in lat/lon
                        var rlat = (kmlObject.overlays[i].radius / earthsradius) * r2d;
                        var rlng = rlat / Math.cos(kmlObject.overlays[i].center.lat * d2r);

                        var extp = new Array();
                        if (dir == 1) { var start = 0; var end = points + 1 } // one extra here makes sure we connect the line
                        else { var start = points + 1; var end = 0 }
                        for (var j = start; (dir == 1 ? j < end : j > end); j = j + dir) {
                            var theta = Math.PI * (j / (points / 2));
                            ey = kmlObject.overlays[i].center.lng + (rlng * Math.cos(theta)); // center a + radius x * cos(theta)
                            ex = kmlObject.overlays[i].center.lat + (rlat * Math.sin(theta)); // center b + radius y * sin(theta)
                            xw.writeString(ey + "," + ex + "," + flightAltitude);
                        }
                        xw.writeEndElement();
                        xw.writeEndElement();
                        xw.writeEndElement();
                    } else {
                        for (var j = 0; j < kmlObject.overlays[i].paths.length; j++) {
                            if (j == 0) {
                                xw.writeStartElement('outerBoundaryIs');
                            } else {
                                xw.writeStartElement('innerBoundaryIs');
                            }
                            xw.writeStartElement('LinearRing');
                            xw.writeStartElement("coordinates");
                            for (var k = 0; k < kmlObject.overlays[i].paths[j].length; k++) {
                                xw.writeString(kmlObject.overlays[i].paths[j][k].lng + "," + kmlObject.overlays[i].paths[j][k].lat + "," + flightAltitude);
                            }
                            xw.writeEndElement();
                            xw.writeEndElement();
                            xw.writeEndElement();
                        }
                    }
                    xw.writeEndElement();

                } else if (kmlObject.overlays[i].type == "polyline") {
                    xw.writeStartElement('LineString');
                    xw.writeElementString('extrude', '1');
                    xw.writeElementString('altitudeMode', 'relativeToGround');
                    xw.writeStartElement("coordinates");
                    calculatedFlightAltitude = flightAltitude;
                    for (var j = 0; j < kmlObject.overlays[i].path.length; j++) {
                        // Calcualte the correct altitude with elevation from waypoint
                        var flightPointElevation = flightPathElevations[j];
                        var diffElevation = parseInt(flightPointElevation.elevation - takeOffElevation);

                        console.log("Elevation : " + flightPointElevation + " diff is " + diffElevation);

                        // check diff, if more than 2 meters we adjust the drone height
                        if (diffElevation > 2) {
                            calculatedFlightAltitude = diffElevation + flightAltitude;
                        } 

                        xw.writeString(kmlObject.overlays[i].path[j].lng + "," + kmlObject.overlays[i].path[j].lat + "," + calculatedFlightAltitude);
                    }
                    xw.writeEndElement();
                    xw.writeEndElement();

                }

                xw.writeEndElement(); // END PlaceMarker
            }

            xw.writeEndElement();
            xw.writeEndElement();
            xw.writeEndDocument();

            var xml = xw.flush(); //generate the xml string
            xw.close();//clean the writer
            xw = undefined;//don't let visitors use it, it's closed
            
            //set the xml to kml
            kml = xml;
            document.getElementById('kmlString').value = xml;

            // Start file download.
            download();
        }

        function mapToObject() {
            var tmpMap = new Object;
            var tmpOverlay, paths;
            tmpMap.zoom = map.getZoom();
            tmpMap.tilt = map.getTilt();
            tmpMap.mapTypeId = map.getMapTypeId();
            tmpMap.center = { lat: map.getCenter().lat(), lng: map.getCenter().lng() };
            tmpMap.overlays = new Array();

            for (var i = 0; i < mapOverlays.length; i++) {
                if (mapOverlays[i].getMap() == null) {
                    continue;
                }
                tmpOverlay = new Object;
                tmpOverlay.type = mapOverlays[i].type;
                tmpOverlay.title = mapOverlays[i].title;
                tmpOverlay.content = mapOverlays[i].content;

                if (mapOverlays[i].fillColor) {
                    tmpOverlay.fillColor = mapOverlays[i].fillColor;
                }

                if (mapOverlays[i].fillOpacity) {
                    tmpOverlay.fillOpacity = mapOverlays[i].fillOpacity;
                }

                if (mapOverlays[i].strokeColor) {
                    tmpOverlay.strokeColor = mapOverlays[i].strokeColor;
                }

                if (mapOverlays[i].strokeOpacity) {
                    tmpOverlay.strokeOpacity = mapOverlays[i].strokeOpacity;
                }

                if (mapOverlays[i].strokeWeight) {
                    tmpOverlay.strokeWeight = mapOverlays[i].strokeWeight;
                }

                if (mapOverlays[i].icon) {
                    tmpOverlay.icon = mapOverlays[i].icon;
                }

                if (mapOverlays[i].flat) {
                    tmpOverlay.flat = mapOverlays[i].flat;
                }

                if (mapOverlays[i].type == "polygon") {
                    tmpOverlay.paths = new Array();
                    paths = mapOverlays[i].getPaths();
                    for (var j = 0; j < paths.length; j++) {
                        tmpOverlay.paths[j] = new Array();
                        for (var k = 0; k < paths.getAt(j).length; k++) {
                            tmpOverlay.paths[j][k] = { lat: paths.getAt(j).getAt(k).lat().toString(), lng: paths.getAt(j).getAt(k).lng().toString() };
                        }
                    }

                } else if (mapOverlays[i].type == "polyline") {
                    const points = [];
                    tmpOverlay.path = points;
                    path = mapOverlays[i].getPath();
                    for (var j = 0; j < path.length; j++) {
                        var loc = { lat: path.getAt(j).lat(), lng: path.getAt(j).lng() };
                        tmpOverlay.path[j] = loc;
//                        points.push(loc);
                    }
                    
//                    tmpOverlay.path = new Array();
//                    path = mapOverlays[i].getPath();
//                    for (var j = 0; j < path.length; j++) {
//                        tmpOverlay.path[j] = { lat: path.getAt(j).lat().toString(), lng: path.getAt(j).lng().toString() };
//                    }                    
                    
                    getFlightPathElevations(points);

                } else if (mapOverlays[i].type == "circle") {
                    tmpOverlay.center = { lat: mapOverlays[i].getCenter().lat(), lng: mapOverlays[i].getCenter().lng() };
                    tmpOverlay.radius = mapOverlays[i].radius;
                } else if (mapOverlays[i].type == "rectangle") {
                    tmpOverlay.bounds = {
                        sw: { lat: mapOverlays[i].getBounds().getSouthWest().lat(), lng: mapOverlays[i].getBounds().getSouthWest().lng() },
                        ne: { lat: mapOverlays[i].getBounds().getNorthEast().lat(), lng: mapOverlays[i].getBounds().getNorthEast().lng() }
                    };
                } else if (mapOverlays[i].type == "marker") {
                    tmpOverlay.position = { lat: mapOverlays[i].getPosition().lat(), lng: mapOverlays[i].getPosition().lng() };
                }
                tmpMap.overlays.push(tmpOverlay);
            }
            kmlObject = tmpMap;
            setflightAltitude = parseInt(document.getElementById("flightAltitude").value);
            const downloadButton = document.querySelector('downloadButton');

            const disableButton = () => {
                downloadButton.disabled = false;
            };
        }


        function formatDate(date, format) {
            const map = {
                mm: ("0" + (date.getMonth() + 1)).slice(-2),
                dd: ("0" + date.getDate()).slice(-2),
                yyyy: date.getFullYear(),
                yy: date.getFullYear().toString().slice(-2),
                hh: ("0" + date.getHours()).slice(-2),
                mi: ("0" + date.getMinutes()).slice(-2)
            }

            return format.replace(/mm|dd|yyyy|yy|hh|mi/gi, matched => map[matched])
        }

    </script>
</body>

</html>
